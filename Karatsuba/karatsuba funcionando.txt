#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <list>
#include <string>
#include <iostream>
#include <algorithm>
#include <time.h>
using namespace std;
int passos=0;
typedef unsigned int uint32;

enum PaddingType { LEFT, RIGHT };

///
/// Preenche um char n vezes na string a direita ou na esquerda
///
string padString(const string& toPad, size_t paddingCountToAdd, char paddingChar, PaddingType paddingType = RIGHT) {
    string s(paddingCountToAdd, paddingChar);
    return paddingType == LEFT ? s + toPad : toPad + s;
}

///
/// Verifica se a string é composta de apenas '0's
///
bool isZero(const string& oper) {
    for (size_t i = 0, l = oper.size(); i < l; i++)
        if (oper[i] != '0') return false;
    return true;
}

///
/// Dadas duas strings, ambas representando números, retorna uma nova string que representa a soma delas
///
string sumIntStrings(const string& op1, const string& op2, int base) {
    if (op2 == "") return op1;
    if (op1 == "") return op2;
    string total = "";
    size_t op1Size = op1.size();
    size_t op2Size = op2.size();
    size_t m = max(op1Size, op2Size);

    uint32 carry = 0;
    for (int i = 0; i < static_cast<int>(m); i++) {
        uint32 c0 = i < op1Size ? op1[op1Size - 1 - i] - '0' : 0;
        uint32 c1 = i < op2Size ? op2[op2Size - 1 - i] - '0' : 0;
        uint32 c = c0 + c1 + carry;
        carry = c / base;
        total += (c % base) + '0';
    }
    if (carry) total += carry + '0';
    reverse(total.begin(), total.end());
    return total;
}

///
/// Remove os zeros da esquerda do número
///
string removeLeftZeros(const string& value) {
    // Delete '0's from the left
    if (value.size() > 1 && value[0] == '0') {
        for (size_t i = 0, l = value.size(); i < l; i++) {
            if (value[i] == '0')
                continue;
            return value.substr(i, l - i);
        }
    }
    return value;
}

///
/// Dadas duas strings, ambas representando números, retorna uma nova string
/// que representa a subtração delas, para isso, assume que o primeiro parâmetro
/// seja sempre maior ou igual ao segundo parâmetro
///
string subIntStrings(const string& op1, const string& op2, int base) {
    if (op2 == "") return op1;

    string total = "";
    size_t op1Size = op1.size();
    size_t op2Size = op2.size();

    uint32 carry = 0;
    for (int i = 0; i < op1Size; i++) {
        int c0 = op1[op1Size - 1 - i] - '0' - carry;
        int c1 = i < op2Size ? op2[op2Size - 1 - i] - '0' : 0;
        carry = 0;
        if (c0 < c1) {
            carry = 1;
            c0 += base;
        }
        total += (c0 - c1) + '0';
    }
    reverse(total.begin(), total.end());
    return isZero(total) ? "0" : removeLeftZeros(total);
}

///
/// Retorna uma string que representa o produto do primeiro parâmetro pelo
/// dígito que o segundo parâmetro representa
///
string mulIntStringByChar(const string& op1, const char op2, int base) {
    if (op2 == '0') return "0";
    if (op2 == '1') return op1;

    int carry = 0;
    int d0 = op2 - '0';
    string r = "";
    for (int j = op1.size() - 1; j >= 0; j--) {
        int d1 = op1[j] - '0';
        int d = (d0 * d1) + carry;
        carry = d / base;
        d %= base;
        r += d + '0';
    }
    if (carry) r += carry + '0';
    reverse(r.begin(), r.end());
    return r;
}

///
/// Aqui ficar a forma padrão recursiva de multiplicação
///
string multPadrao(const string& op1, const string& op2) {

    string total = "";

    return total;
}

///
/// Executa a multiplicação de karatsuba nas duas cadeias de parâmetros
/// (ambas representando números)
///
string multKaratsuba(const string& oper1, const string& oper2, int base) {
    // 2 * O(n)
    if (isZero(oper1) || isZero(oper2))
        return "0";
    // 2 * O(n)
    string op1 = removeLeftZeros(oper1);
    string op2 = removeLeftZeros(oper2);
    // O(1) (theoritically)
    size_t l1 = op1.size();
    size_t l2 = op2.size();
    if (l1 == 1 || l2 == 1)
        // O(1)
        return mulIntStringByChar(l1==1?op2:op1,l1==1?op1[0]:op2[0],base);
    // Divide
    size_t n = max(l1, l2);
    n += (n & 1);
    // 2 * O(n)
    op1 = padString(op1, n - l1, '0', LEFT);
    op2 = padString(op2, n - l2, '0', LEFT);
    size_t n2 = n / 2;
    // 4 * O(n)
    string a = op1.substr(0, n2);
    string b = op1.substr(n2, n2);
    string c = op2.substr(0, n2);
    string d = op2.substr(n2, n2);
    // 2 recursive calls
    string ac = multKaratsuba(a, c, base);
    string bd = multKaratsuba(b, d, base);
    // 2 * O(n)
    string _ab = sumIntStrings(a, b, base);
    string _cd = sumIntStrings(c, d, base);
    // another call
    string abcd = multKaratsuba(_ab, _cd, base);
    // 2 * O(n)
    abcd = subIntStrings(abcd, ac, base);
    abcd = subIntStrings(abcd, bd, base);
    // 5 * O(n)
    ac = padString(ac, n, '0', RIGHT);
    abcd = padString(abcd, n2, '0', RIGHT);
    string res = sumIntStrings(ac, abcd, base);
    res = sumIntStrings(res, bd, base);
    return removeLeftZeros(res);
}

int main(){
    printf("Trabalho de ASA 2019-2\nFlavio Miranda de Farias\n");
    while(1){
        fflush(stdin);
        int base,t1,t2,i;
        printf("\nDigite a Base: ");
        scanf(" %d",&base);
        printf("Tamanho da string 1: ");
        scanf(" %d",&t1);
        printf("Tamanho da string 2: ");
        scanf(" %d",&t2);
        std::string s1,s2;
        char repetir,temp;
        printf("\nString 1(char[]): ");
        for(i=0;i<t1;i++){
            temp=(rand()%base)+48;
            s1.push_back(temp);
            printf("%c ",temp);
        }
        printf("\nString 2(char[]): ");
        for(i=0;i<t2;i++){
            temp=(rand()%base)+48;
            s2.push_back(temp);
            printf("%c ",temp);
        }

        cout << endl << "Cronometragem do algoritmo karatsuba...\n" << endl;
        clock_t start = clock();
        cout << multKaratsuba(s1, s2, base)+"\n";
        clock_t time = clock() - start;
        cout << "\nTempo gasto pelo Karatsuba = " << static_cast<float>(time) / CLOCKS_PER_SEC << endl;

        printf("\nPara a multiplicacao de strings, foram realizados %d passos\n",passos);
        passos=0;
        printf("\n\nRepetir? (s/n): ");
        scanf(" %c",&repetir);
        system("cls");
        if(repetir!='s')
            return 0;
    }
}

